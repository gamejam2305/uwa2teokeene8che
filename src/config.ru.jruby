require "bundler/setup"

# JRuby-specific optimizations
if defined?(JRUBY_VERSION)
  puts "Running on JRuby #{JRUBY_VERSION}"
  
  # JRuby system properties are better set via environment variables
  # but we can still set some programmatically if needed
  begin
    require 'java'
    
    # Only set properties if not already set via environment
    unless ENV['JRUBY_OPTS']&.include?('invokedynamic')
      Java::JavaLang::System.setProperty('jruby.compile.invokedynamic', 'true')
    end
    Java::JavaLang::System.setProperty('jruby.thread.pool.enabled', 'true')
    
    puts "JRuby optimizations applied"
  rescue => e
    puts "Warning: Could not set JRuby optimizations: #{e.message}"
  end
  
  # Use faster JSON library for JRuby if available
  begin
    require 'jrjackson'
    # Replace standard JSON with JrJackson for better performance
    JSON = JrJackson::Json
    puts "Using JrJackson for JSON parsing"
  rescue LoadError
    # Fall back to standard JSON if JrJackson is not available
    require 'json'
    puts "Using standard JSON library"
  end
else
  require 'json'
end

# Determine which application to load based on available files
app_to_load = nil

# First try to load the main prometheus exporter app
begin
  require_relative "prometheus_exporter"
  app_to_load = PrometheusExporterApp
  puts "Loaded PrometheusExporterApp"
rescue LoadError => e
  puts "Could not load prometheus_exporter: #{e.message}"
  
  # Fallback to victima app if prometheus exporter fails
  begin
    require_relative "victima"
    app_to_load = TargetApp
    puts "Loaded TargetApp as fallback"
  rescue LoadError => e2
    puts "Could not load victima either: #{e2.message}"
    raise "No application could be loaded"
  end
end

# Add health check middleware
class HealthCheckMiddleware
  def initialize(app)
    @app = app
  end
  
  def call(env)
    if env['PATH_INFO'] == '/health'
      [200, {'Content-Type' => 'text/plain'}, ['OK']]
    else
      @app.call(env)
    end
  end
end

# Configure middleware stack
use HealthCheckMiddleware

# Add request logging middleware
use Rack::CommonLogger, $stdout

# Add request timing middleware for monitoring
class RequestTimingMiddleware
  def initialize(app)
    @app = app
  end
  
  def call(env)
    start_time = Time.now
    status, headers, response = @app.call(env)
    duration = Time.now - start_time
    
    # Log request timing (helpful for JRuby performance monitoring)
    if ENV['LOG_LEVEL'] == 'debug'
      puts "Request to #{env['PATH_INFO']} took #{duration.round(3)}s"
    end
    
    [status, headers, response]
  end
end

use RequestTimingMiddleware if ENV['RACK_ENV'] == 'development'

# Run the detected application
if app_to_load
  puts "Starting #{app_to_load.name}..."
  run app_to_load
else
  # Ultimate fallback - simple health check app
  puts "Using fallback health check app"
  run ->(env) {
    [200, {'Content-Type' => 'text/plain'}, ['JRuby Health Check OK']]
  }
end
